c
json
c
json
c
json
c
invalid_attributes
c
invalid_attributes
invalid_parameters
c
json
n
json
c
json
n
json
c
invalid_attributes
c
params
c
n
@feedback.errors
n
c
n
@feedback.save
authorize @feedback
n
c
@logged_user
valid_attributes
c
e.message.split('?').first
e.message.split('?')
e.message
e
c
@user.id
current_user
params
c
@record
c
json
c
current_user.id
current_user
feedback_params
feedback_param
c
given_feedback_params
c
params
c
current_user.id
params
c
given_feedback_params
params
c
time.new(json['given_feedbacks'].first['created_at']).strftime("%Y/%m/%d %H:%M:%S")
json['given_feedbacks'].first['created_at'].strftime("%Y/%m/%d %H:%M:%S")
json['given_feedbacks'].first['created_at']
json['given_feedbacks'].first.created_at
json['given_feedbacks'].first
json['given_feedbacks'].firat
json['given_feedbacks']
json.given_feedbacks
json
.strftime("%Y/%m/%d %H:%M:%S")
c
ActiveModel::ArraySerializer.new(given_feedbacks, each_serializer: FeedbackSerializer).as_json
ActiveModel::ArraySerializer.new(given_feedbacks, each_serializer: FeedbackSerializer).to_json
ActiveModel::ArraySerializer.new(Funding.all, each_serializer: FundingSerializer).to_json
 FeedbackSerializer.new(given_feedbacks.first, expand: true).serializable_hash
FeedbackSerializer.methods
FeedbackSerializer
 FeedbackSerializer.new(given_feedbacks, expand: true).serializable_hash
c
a.to_json
a = FeedbackSerializer.new @given_feedbacks
FeedbackSerializer.new @given_feedbacks
FeedbackSerializer
SerializableFeedback
SerializableResource
  end
    super.merge(time: time.strftime('%d.%m.%Y %H:%M:%S'))
def as_json(options = {})
c
given_feedbacks.class
given_feedbacks
c
SerializableResource.new(Feedback)
SerializableResource.new(Feedback, options)
c
SerializableResource.new(Feedback, options)
c
continue
SerializableResource.new(Feedback, options)
@given_feedbacks.to_json
@given_feedbacks.last
@given_feedbacks.size
@given_feedbacks
c
json
c
current_user.given_feedback.size
current_user.given_feedback
current_user
User.first
c
exception
n
c
response.body
c
f.created_at
f = Feedback.first
c
n
c
n
c
controller.stub!(:authorize).and_return(User)
controller.stub!(:authorize)
controller.stub!(:authenticate_user!)
controller.stub!(authenticate)
controller.stub!(authenticate_user!)
controller.stub
controller
c
controller
c
feedback.errors['rating']
feedback.errors['text']
feedback.errors['base']
feedback.errors[''base]
feedback.errors.base
feedback.errors
feedback
c
a.writer
a.subject
a
c
a.writer
a
c
build :feedback
c
build :feedback
c
build :feedback
c
build :feedback
c
build :feedback
c
build :feedback
c
build :feedback
c
build :feedback
c
build :feedback
c
build :feedback
c
build :feedback
c
json
c
json['errors']
json
c
valid_user[:email]
valid_user.email
valid_user
ActionMailer::Base.deliveries.last.to
ActionMailer::Base.deliveries.last
ActionMailer::Base.deliveries
c
ActionMailer::Base.deliveries.first.body
ActionMailer::Base.deliveries.first
ActionMailer::Base.deliveries
n
ActionMailer::Base.deliveries = []
ActionMailer::Base.deliveries
c
json[:email]
json['email']
json.email
json
expect(json.first[:email]).to eq user.email
json.first['email']
user.email
user
c
json
c
n
user.name
n
user.name
c
a['name']
a[:name]
a.class
a.name
a
a = JSON.parse response.body
JSON.pars response.body
response.body
json
n
c
n
c
n
json
n
c
valid_user
response.body
response.status
n
c
n
valid_user
user
n
user
valid_user
c
user
n
user
c
response.body
c
response.body
c
@error
c
@error
@error = 'pippo'
@error
@erro
c
@error
c
@error
